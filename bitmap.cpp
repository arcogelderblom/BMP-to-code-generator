/*
============================================================================
	File: 		bitmap.hpp
	Contains:	Implementation of the functions declared in
	the header file
	Made by:	Arco Gelderblom 2016
	Distributed under the Boost Software License, Version 1.0.		
 	(See accompanying file LICENSE_1_0.txt in folder 'License' or 
	copy at http://www.boost.org/LICENSE_1_0.txt) 
============================================================================
*/

#include "bitmap.hpp"

bitmap::bitmap(char * filename) :
	filename( filename ) 
{
	//open the given file binary
	file.open(filename, std::ios::binary);
	
	//when it is possible to open the file do the following things
	if( file.is_open() ) {
		std::cout << "Succes! " << filename << " is opened."<<'\n';
		int size_bmpheader = 54; //size of the header of a bmp is 54
		char* headerbuffer = new char [size_bmpheader];
		file.read(headerbuffer, size_bmpheader);
		
		width = ( ( headerbuffer[21]*(16*16*16*16*16*16) ) + ( headerbuffer[20]*(16*16*16*16) ) + ( headerbuffer[19]*(16*16) ) + headerbuffer[18] ); //byte 18, 19, 20, 21 represent the image width
		heigth = ( ( headerbuffer[25]*(16*16*16*16*16*16) ) + ( headerbuffer[24]*(16*16*16*16) ) + ( headerbuffer[23]*(16*16) ) + headerbuffer[22] ); //byte 22, 23, 24, 25 represent the image heigth
	}
	//if it isn't possible to open the file say this to the user
	else {
		std::cout << "Program was unable to open given file: " << filename <<'\n';
	}
	file.close();
}

void bitmap::use_nokia5510( void ) {
	int max_width = 84;
	int max_heigth = 48;
	if( ( max_width >= width ) && ( max_heigth >= heigth ) ) {
		std::cout<<"The used .bmp file is usable on a Nokia 5510 screen."<<'\n';
	}
	else {
		std::cout<<"The used .bmp file is not usable on a Nokia 5510 screen because of the resolution."<<'\n';
	}
}

int bitmap::get_width( void ) {
	return width;
}

int bitmap::get_heigth( void ) {
	return heigth;
}

int bitmap::check_padding( void ) {
	std::cout<<"start checking padding"<<'\n';
	file.open(filename, std::ios::binary);
	int file_length = 2*3*width; // every pixel is 3 bytes, do this times 2 to be sure you've got the padding
	file.seekg(54, file.beg); // start reading after the header

	char* buffer = new char [file_length];
	file.read(buffer, file_length);
	int padding = 0;
	int i=0;
	int j=1;
	int k=2;
	int pixelnr=1;
	while(1) {
			if ((pixelnr % (width*1) == 0)) {
				i=k;
				j=k+1;
				k=k+2;
				while( (i % 4) != 0) {
					i++;
					j++;
					k++;
					padding++;
				}
				break;
			}
			i+=3;
			j+=3;
			k+=3;
			pixelnr++;
	}
	file.close();
	std::cout<<"padding checked"<<'\n';
	std::cout<<"padding is: "<<(padding-1)<<'\n'; //padding -1 because index needs to skip x times so the actual padding (amount of useless bytes) is x-1
	return padding;
}

void bitmap::get_black_pixels( char * out_file ) {
	int padding = check_padding();
	int max_width = 84;
	int max_heigth = 48;
	int i=0;
	int j=1;
	int k=2;
	int pixelnr=1;
	int amount_of_black_pixels = 0;
	
	//open the given file binary
	file.open(filename, std::ios::binary);
	int file_length = ((3*width*heigth)+(heigth*(padding-1))); //skip the 54 bytes header, padding -1 because index needs to skip x so the actual padding is x-1
	file.seekg(54, file.beg);
	char* buffer = new char [file_length];
	file.read(buffer, file_length); //read the file and store everything in the buffer
	
	std::ofstream file_out;
	file_out.open(out_file, std::ofstream::out);
	
	//calculate amount of black pixels (nessecary for array that is being made in file)
	for(int row = 1; row <= heigth; row++) {
		while(k!=file_length) {
			unsigned int b = buffer[i];
			unsigned int g = buffer[j];
			unsigned int r = buffer[k];
			if( r == 0x00 && g == 0x00 && b == 0x00 ) { //detect black 
				amount_of_black_pixels++;
			}
			
			if ((pixelnr % (width*row) == 0)) {
				i=k+padding;
				j=k+1+padding;
				k=k+2+padding;
				pixelnr++;
				break;
			}
			i+=3;
			j+=3;
			k+=3;
			pixelnr++;
		}
	}

	//setup everything for an hpp file
	file_out<<"///@file"<<'\n'<<"#ifndef IMAGE_HPP"<<'\n'<<"#define IMAGE_HPP"<<'\n'<<"/// Class image"<<'\n'<<"//"<<'\n'<<"/// Class image as generated by the generator convert img to array made by Arco Gelderblom"<<'\n'<<"class image {"<<'\n'<<"public:"<<'\n'<<"/// Array containing all black pixels out of the bmp file"<<'\n'<<"int coordinates_black_pixels["<<amount_of_black_pixels<<"][2] = {";
	
	std::cout<<"Start loading all black pixels in array."<<'\n';
	amount_of_black_pixels = 0;
	i=0;
	j=1;
	k=2;
	pixelnr=1;
	
	for(int row = 1; row <= heigth; row++) {
		while(k!=file_length) {
			unsigned int b = buffer[i];
			unsigned int g = buffer[j];
			unsigned int r = buffer[k];
			if( r == 0x00 && g == 0x00 && b == 0x00 ) { //detect black 
				// to make sure everything goes correct with ',' 3 if statements
				// the calculation for x and y is done to make sure every image gets centered on the nokia 5510
				if(amount_of_black_pixels == 0) {
					file_out<<"{"<<((pixelnr-(width*(row-1)))+((max_width/2)-(width/2)))<<","<<(((row-heigth)*-1)+((max_heigth/2)-(heigth/2)))<<"},";
				}
				else if(amount_of_black_pixels == 1) {
					file_out<<"{"<<((pixelnr-(width*(row-1)))+((max_width/2)-(width/2)))<<","<<(((row-heigth)*-1)+((max_heigth/2)-(heigth/2)))<<"}";
				}
				else if(amount_of_black_pixels > 1) {
					file_out<<",{"<<((pixelnr-(width*(row-1)))+((max_width/2)-(width/2)))<<","<<(((row-heigth)*-1)+((max_heigth/2)-(heigth/2)))<<"}";
				}
				amount_of_black_pixels++;
			}
			
			if ((pixelnr % (width*row) == 0)) {
				i=k+padding;
				j=k+1+padding;
				k=k+2+padding;
				pixelnr++;
				break;
			}
			i+=3;
			j+=3;
			k+=3;
			pixelnr++;
		}
	}
	file_out<<"};"<<'\n'<<"/// Amount of black pixels in array, necessary for the used loop"<<'\n'<<"int amount_of_black_pixels = "<<amount_of_black_pixels<<";"<<'\n'<<"};"<<'\n'<<'\n'<<"#endif //IMAGE_HPP";
	
	file_out.close();
	std::cout<<"All black pixels are loaded in an array located in file: "<<filename<<'\n';
	file.close();
}